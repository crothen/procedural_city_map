export interface KnowledgeSection {
    heading: string;
    content: string;
}

export interface KnowledgeEntry {
    title: string;
    subtitle: string;
    sections: KnowledgeSection[];
}

export const KNOWLEDGE_BASE = {
    sections: {
        mapParams: {
            title: "Map & Coordinates",
            subtitle: "The Mathematical Foundation",
            sections: [
                {
                    heading: "Coordinate System",
                    content: "The simulation uses a continuous Cartesian coordinate system (x, y) measured in meters, where (0,0) is the top-left corner. Unlike tile-based games, coordinates are floating-point values, allowing for organic geometry and arbitrary angles."
                },
                {
                    heading: "Spatial Hashing",
                    content: "To optimize performance, the map is internally partitioned into a 'Spatial Hash Grid'. This allows the engine to quickly query 'what is near me?' without checking every single object in the world. This is crucial for collision detection during road generation."
                },
                {
                    heading: "Reset Behavior",
                    content: "Changing dimensions triggers a hard reset. This is because the spatial hash grid must be re-initialized with new bucket sizes, and all existing road graphs would become invalid if the bounds shifted."
                }
            ]
        },
        cityParams: {
            title: "Urban Density Model",
            subtitle: "Controlling the Sprawl",
            sections: [
                {
                    heading: "Radial Density Function",
                    content: "The city's growth is governed by a density function `D(x,y)`. We calculate the distance from the map center and normalize it against the `City Size` parameter. This creates a circular gradient where density is 1.0 (Downtown) at the center and 0.0 (Wilderness) at the edge."
                },
                {
                    heading: "Curve Mapping",
                    content: "The linear distance is remapped using an easing curve (often a smoothstep or sigmoid). The 'Falloff' parameter controls the steepness of this curve. A steep falloff creates a sharp boundary (like a European walled city), while a gentle falloff creates American-style suburban sprawl."
                },
                {
                    heading: "Noise Injection",
                    content: "To prevent perfect circles, we inject Perlin Noise into the density calculation. The 'Randomness' parameter controls the amplitude of this noise, creating 'satellite towns' (local maxima) and 'parks' (local minima) within the city limits."
                }
            ]
        },
        waterParams: {
            title: "Hydrology Engine",
            subtitle: "Terrain Constraints",
            sections: [
                {
                    heading: "Procedural Rivers",
                    content: "Rivers are generated using a 'Random Walk' algorithm biased towards a target edge. The generator places a source point and 'flows' downhill (or in a persistent direction) until it hits the map boundary. The generated path is stored as a polygon, which effectively becomes a 'barrier' for the road sizing agent."
                },
                {
                    heading: "Voronoi Lakes",
                    content: "Lakes are generated by seeding random points and calculating Voronoi regions. We select specific regions to be water bodies and smooth their edges using Chaikin's corner cutting algorithm to create natural-looking shorelines."
                },
                {
                    heading: "Road Adaptation",
                    content: "When the road agent encounters water, it initiates a 'Bridge Building' state. It attempts to cross perpendicular to the water flow to minimize bridge length. If the water body is too wide (like a Coast), the road will turn and follow the shoreline instead."
                }
            ]
        },
        roadParams: {
            title: "L-System Road Generator",
            subtitle: "Turtle Graphics & Agents",
            sections: [
                {
                    heading: "The Agent (Turtle)",
                    content: "Roads are generated by autonomous agents that crawl across the map. Each step, the agent casts a ray to check for collisions with existing roads or water. It effectively 'draws' the road network in real-time."
                },
                {
                    heading: "Branching Systems",
                    content: "Based on L-Systems (Lindenmayer Systems), the agent has probabilities to 'branch' (spawn a new agent) or 'terminate'. High branching factors create recursive fractal-like growth patterns typical of organic cities."
                },
                {
                    heading: "Strategies",
                    content: "• **Organic**: The agent's direction is perturbed by Perlin noise at each step.\n• **Grid**: The agent snaps its heading to 90-degree increments.\n• **Radial**: The headings are calculated relative to the map center, creating concentric rings and spokes."
                },
                {
                    heading: "Graph Repair",
                    content: "After generation, the system runs a 'Snapping' pass. Loose road ends that are close to other nodes are snapped together to form closed loops. This is essential for the next phase: Plot Generation."
                }
            ]
        },
        plotParams: {
            title: "Plot Partitioning",
            subtitle: "From Graph to Geometry",
            sections: [
                {
                    heading: "Cycle Finding",
                    content: "The system analyzes the road network (a graph of nodes and edges) to find 'Minimum Enclosed Cycles'. Each closed loop of roads effectively defines a 'City Block'."
                },
                {
                    heading: "Shrinkage",
                    content: "The base polygon of the block is shrunk inwards (inset) by a margin (set by road width) to create the buildable area. This prevents buildings from overlapping the street."
                },
                {
                    heading: "The Cleanup Phase",
                    content: "Procedural generation is messy. The cleanup phase runs geometry validity checks: Is the polygon convex? Is it self-intersecting? Is the areas too small? Invalid polygons are either merged into neighbors or discarded to become small parks."
                }
            ]
        },
        buildingParams: {
            title: "Recursive Subdivision",
            subtitle: "Procedural Architecture",
            sections: [
                {
                    heading: "OBB Algorithm",
                    content: "To split a plot into lots, we calculate the Oriented Bounding Box (OBB) aligned with the longest edge. This ensures lots are perpendicular to the street."
                },
                {
                    heading: "Recursive Split",
                    content: "If a plot is larger than `Max Building Area`, it is split in half along its shorter axis. This process repeats recursively until all child lots are within the target size range."
                },
                {
                    heading: "Irregularity",
                    content: "Ideally, splits are perfectly centered (0.5). The 'Irregularity' parameter perturbs this split point (e.g., to 0.4 or 0.6) and adds angular jitter to the splitting line. This creates the chaotic, charming look of medieval towns compared to the strict grids of modern cities."
                }
            ]
        },
        viewParams: {
            title: "Visualization & Debug",
            subtitle: "Under the Hood",
            sections: [
                {
                    heading: "Debug Overlays",
                    content: "These layers render the internal data structures of the engine. Seeing the 'City Limit Gradient' helps visualize exactly why the generator stopped building in a certain area (density dropped below threshold)."
                }
            ]
        }
    },
    tooltips: {
        // Map Settings
        width: "The horizontal bounds of the simulation space in meters. Larger maps require more processing power.",
        height: "The vertical bounds of the simulation space in meters.",

        // City Settings
        innerCitySize: "The 'Downtown' radius. Inside this circle, the generator attempts to maximize density and building height.",
        hardCityLimit: "Enforces a medieval-style hard boundary. Roads will naturally terminate or turn back when they hit this invisible wall.",
        outerCityFalloff: "The transition zone size. A large falloff creates a massive Suburban sprawl; a small falloff creates a sharp city edge.",
        gradientRandomness: "Injects Perlin noise into the density map. High values create 'satellite towns' and gaps in development.",
        showCityLimitGradient: "Debug View: Renders the density heatmap. Brighter = Higher Density. Useful for tuning falloff settings.",

        // Water Settings
        waterFeature: "Selects the hydrological template from the terrain engine.",
        riverWidth: "Controls the stroke width of the river path. Wider rivers require longer bridges.",

        // Road Settings
        roadStrategy: "Determines the movement ruleset for the road-building agent.",
        branchingFactor: "The 'split chance'. Higher values (e.g., 0.5) create dense, maze-like webs. Lower values (e.g., 0.1) create long, highway-like arterials.",
        segmentLength: "The step size of the agent. Small segments create smooth curves; large segments create angular, blocky distinct shapes.",

        // Plots
        showPlots: "Toggles the rendering of plot polygons (yellow/orange outlines). Useful for inspecting the 'Cleanup' phase results.",

        // Buildings
        minBuildingArea: "Culling threshold. Any lot resulting from subdivision smaller than this (m²) is left as empty open space/park.",
        maxBuildingArea: "The cap for a single structure's footprint. Larger plots will be forced to subdivide further.",
        minEdgeLength: "Geometry cleanup. Edges shorter than this are collapsed to simplify complex polygons.",
        minAngle: "Geometry cleanup. Corners sharper than this (degrees) are beveled or removed to prevent graphical glitches.",
        buildingIrregularity: "Chaos factor. 0.0 = Perfect Grid Subdivision. 0.5 = Highly organic, randomly sized lots.",
        fixedBuildingDepth: "Row-house constraint. If > 0, buildings will ignore the plot center and hug the street edge at this exact depth."
    }
};
